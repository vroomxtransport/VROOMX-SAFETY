---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/models/Violation.js
autonomous: true

must_haves:
  truths:
    - "Violation model stores FMCSA sync metadata (source, importedAt, externalId, lastVerified)"
    - "Violation model stores entity linking metadata (confidenceScore, linkingMethod, linkedAt, reviewRequired)"
    - "Duplicate violations cannot be created (unique constraint on inspectionNumber+violationCode+violationDate)"
  artifacts:
    - path: "backend/models/Violation.js"
      provides: "FMCSA SSOT schema with sync and linking fields"
      contains: "syncMetadata"
    - path: "backend/models/Violation.js"
      provides: "Entity linking preparation"
      contains: "linkingMetadata"
  key_links:
    - from: "backend/models/Violation.js"
      to: "MongoDB collection"
      via: "unique compound index"
      pattern: "inspectionNumber.*violationCode.*violationDate.*unique"
---

<objective>
Add FMCSA sync metadata and entity linking metadata fields to the Violation model, establishing it as the single source of truth for all violation data.

Purpose: The Violation model must capture where data came from (syncMetadata) and how it links to drivers/vehicles (linkingMetadata) to support the automated sync pipeline in Phase 3 and entity linking in Phase 4.

Output: Updated Violation.js with new fields and compound unique index to prevent duplicate imports.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/models/Violation.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add syncMetadata and linkingMetadata fields to Violation schema</name>
  <files>backend/models/Violation.js</files>
  <action>
Add two new embedded objects to the Violation schema, placed after the `notes` field and before the schema options:

1. **syncMetadata** object - tracks FMCSA data origin:
   - source: String, enum ['manual', 'datahub_api', 'saferweb_api', 'fmcsa_sms'], default 'manual'
   - importedAt: Date (when this violation was imported from external source)
   - externalId: String (original ID from external system, if any)
   - lastVerified: Date (when we last confirmed this data matches source)

2. **linkingMetadata** object - for Phase 4 entity linking:
   - driverConfidence: Number (0-100, null if not linked)
   - vehicleConfidence: Number (0-100, null if not linked)
   - linkingMethod: String, enum ['cdl_exact', 'cdl_fuzzy', 'vin_exact', 'vin_fuzzy', 'unit_number', 'manual', null]
   - linkedAt: Date (when linking was performed)
   - reviewRequired: Boolean, default false (true if low confidence needs human review)

Follow existing schema patterns:
- Use nested objects (not subdocument schemas)
- No required: true on these fields (they're optional for manual entries)
- Place defaults where appropriate
  </action>
  <verify>
Run: `node -e "const V = require('./backend/models/Violation'); console.log(Object.keys(V.schema.paths).filter(p => p.startsWith('sync') || p.startsWith('linking')))"`

Expected output should show syncMetadata and linkingMetadata nested paths.
  </verify>
  <done>
Violation schema includes syncMetadata object with source/importedAt/externalId/lastVerified fields, and linkingMetadata object with driverConfidence/vehicleConfidence/linkingMethod/linkedAt/reviewRequired fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add compound unique index for duplicate prevention</name>
  <files>backend/models/Violation.js</files>
  <action>
Add a compound unique index to prevent duplicate violation imports. Place after the existing indexes (around line 212):

```javascript
// Unique constraint to prevent duplicate violation imports
// A violation is uniquely identified by inspection + code + date
violationSchema.index(
  { companyId: 1, inspectionNumber: 1, violationCode: 1, violationDate: 1 },
  { unique: true, sparse: true, name: 'unique_violation_per_inspection' }
);
```

Use `sparse: true` because violationCode can be null for manually entered violations (which don't have CFR codes). The sparse option means the unique constraint only applies when all fields are present.

Also add an index on `syncMetadata.externalId` for fast lookups during sync:

```javascript
// Index for fast lookup during sync by external ID
violationSchema.index({ 'syncMetadata.externalId': 1 }, { sparse: true });
```
  </action>
  <verify>
Run: `node -e "const V = require('./backend/models/Violation'); console.log(Object.keys(V.schema.indexes()).length, 'indexes defined')"`

Verify index count increased by 2 from the original 6 to 8.
  </verify>
  <done>
Violation model has compound unique index on (companyId, inspectionNumber, violationCode, violationDate) preventing duplicate imports, and sparse index on syncMetadata.externalId for sync lookups.
  </done>
</task>

</tasks>

<verification>
1. Schema loads without errors: `node -e "require('./backend/models/Violation')"`
2. New fields exist: Check schema.paths includes syncMetadata.* and linkingMetadata.* paths
3. Indexes defined: Schema has 8 indexes total (6 original + 2 new)
4. Backend starts: `cd backend && npm run dev` starts without errors (ctrl-c after startup)
</verification>

<success_criteria>
- Violation.js contains syncMetadata object with source, importedAt, externalId, lastVerified fields
- Violation.js contains linkingMetadata object with driverConfidence, vehicleConfidence, linkingMethod, linkedAt, reviewRequired fields
- Compound unique index exists for duplicate prevention
- Backend server starts successfully with updated model
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
