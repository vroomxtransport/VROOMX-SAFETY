---
phase: 09-unified-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/utils/datePresets.js
  - frontend/src/utils/reportFilterConfig.js
  - frontend/src/utils/api.js
  - backend/routes/reports.js
autonomous: true

must_haves:
  truths:
    - "Date presets return correct date ranges (Last 30 days, This Quarter, YTD)"
    - "Backend accepts driverIds, vehicleIds, complianceStatus query params"
    - "Empty filter arrays return all results, not zero results"
    - "Frontend API serializes arrays to comma-separated strings"
  artifacts:
    - path: "frontend/src/utils/datePresets.js"
      provides: "Date range preset calculations"
      exports: ["getDatePresets", "getActivePreset"]
    - path: "frontend/src/utils/reportFilterConfig.js"
      provides: "Per-report filter configuration"
      exports: ["REPORT_FILTER_CONFIG"]
    - path: "backend/routes/reports.js"
      provides: "Extended filter query param handling"
      contains: "driverIds.split"
  key_links:
    - from: "frontend/src/utils/datePresets.js"
      to: "date-fns"
      via: "import { subDays, startOfQuarter, startOfYear, format }"
      pattern: "import.*from.*date-fns"
    - from: "backend/routes/reports.js"
      to: "Driver model"
      via: "$in query operator"
      pattern: "\\$in.*ids"
---

<objective>
Create filter infrastructure: date presets utility, report filter configuration, backend query parameter handling, and frontend API serialization.

Purpose: Establish the foundation for unified filtering across all reports - utilities, configuration, and API contract.
Output: Working filter utilities and backend endpoints that accept filter parameters.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-unified-filtering/09-RESEARCH.md

# Existing patterns
@frontend/src/utils/api.js
@backend/routes/reports.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create date presets utility and filter config</name>
  <files>
    frontend/src/utils/datePresets.js
    frontend/src/utils/reportFilterConfig.js
  </files>
  <action>
Create `frontend/src/utils/datePresets.js`:
- Import from date-fns: `subDays`, `startOfQuarter`, `startOfYear`, `format`
- Export `getDatePresets()` returning array of preset objects:
  - `{ key: 'last30', label: 'Last 30 Days', startDate, endDate }`
  - `{ key: 'thisQuarter', label: 'This Quarter', startDate, endDate }`
  - `{ key: 'ytd', label: 'Year to Date', startDate, endDate }`
  - `{ key: 'custom', label: 'Custom', startDate: '', endDate: '' }`
- Use `format(date, 'yyyy-MM-dd')` for ISO date strings
- Export `getActivePreset(startDate, endDate)` that compares current dates to presets and returns matching key or 'custom'

Create `frontend/src/utils/reportFilterConfig.js`:
- Export `REPORT_FILTER_CONFIG` object with keys: dqf, vehicle, violations, audit
- Each config has: `enableDateRange`, `enableDriverFilter`, `enableVehicleFilter`, `enableStatusFilter`, `statusOptions[]`, `dateFilterField`
- DQF: driver filter enabled, status options = compliant/warning/non_compliant, dateFilterField = 'hireDate'
- Vehicle: vehicle filter enabled, status options = compliant/warning/non_compliant/out_of_service, dateFilterField = 'annualInspection.nextDueDate'
- Violations: both driver and vehicle filters enabled, status options = open/dispute_in_progress/resolved/dismissed/upheld, dateFilterField = 'violationDate'
- Audit: no filters (snapshot report)
- Each status option: `{ value: '', label: 'All Status' }` as first option, then specific values
  </action>
  <verify>
Run in frontend directory:
```bash
node -e "const p = require('./src/utils/datePresets.js'); console.log(p.getDatePresets()); console.log(p.getActivePreset('2025-01-01', '2025-12-31'));"
node -e "const c = require('./src/utils/reportFilterConfig.js'); console.log(Object.keys(c.REPORT_FILTER_CONFIG));"
```
Both should output without errors (may need ESM adjustments for verification).
  </verify>
  <done>
datePresets.js exports getDatePresets() returning 4 presets with correct date calculations, and getActivePreset() returns matching preset key. reportFilterConfig.js exports REPORT_FILTER_CONFIG with dqf, vehicle, violations, audit configurations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend backend report routes with filter params</name>
  <files>backend/routes/reports.js</files>
  <action>
Extend the existing report routes to accept new filter query parameters:

**DQF route (`GET /api/reports/dqf`):**
- Add query params: `driverIds` (comma-separated), `startDate`, `endDate`, `complianceStatus`
- Parse driverIds: `const ids = driverIds ? driverIds.split(',').filter(Boolean) : []`
- If `ids.length > 0`, add `query._id = { $in: ids }` (replaces single driverId logic)
- If `complianceStatus`, add `query['complianceStatus.overall'] = complianceStatus`
- Date range filters on `hireDate` field

**Vehicle maintenance route (`GET /api/reports/vehicle-maintenance`):**
- Add query params: `vehicleIds` (comma-separated), `startDate`, `endDate`, `complianceStatus`
- Parse vehicleIds similarly to driverIds
- If `ids.length > 0`, add `query._id = { $in: ids }`
- If `complianceStatus`, add `query['complianceStatus.overall'] = complianceStatus`
- Date range filters on `annualInspection.nextDueDate`

**Violations route (`GET /api/reports/violations`):**
- Add query params: `driverIds`, `vehicleIds`, `status`
- Parse both arrays
- If driver ids provided: `query.driverId = { $in: driverIds.split(',').filter(Boolean) }`
- If vehicle ids provided: `query.vehicleId = { $in: vehicleIds.split(',').filter(Boolean) }`
- If status provided: `query.status = status`

**IMPORTANT:** Always check `ids.length > 0` before adding $in filter to avoid returning zero results on empty array.

Keep existing single-item filters (driverId, vehicleId) for backward compatibility - multi-ID filters take precedence if both provided.
  </action>
  <verify>
Test with curl (requires running backend):
```bash
curl -s "http://localhost:5001/api/reports/dqf?format=json&complianceStatus=compliant" -H "Authorization: Bearer $TOKEN" | head -c 500
curl -s "http://localhost:5001/api/reports/violations?format=json&status=open" -H "Authorization: Bearer $TOKEN" | head -c 500
```
Or verify by reading the route code and confirming filter logic is present.
  </verify>
  <done>
All four report routes accept new filter params. DQF accepts driverIds/complianceStatus, vehicle accepts vehicleIds/complianceStatus, violations accepts driverIds/vehicleIds/status. Empty arrays do not trigger $in filter.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update frontend API client for multi-select</name>
  <files>frontend/src/utils/api.js</files>
  <action>
Update `reportsAPI` in api.js to serialize array parameters:

```javascript
export const reportsAPI = {
  getDqfReport: (params) => api.get('/reports/dqf', {
    params: {
      ...params,
      // Convert arrays to comma-separated strings
      driverIds: params.driverIds?.length ? params.driverIds.join(',') : undefined
    },
    responseType: ['pdf', 'csv', 'xlsx'].includes(params.format) ? 'blob' : 'json',
    ...(['pdf', 'csv', 'xlsx'].includes(params.format) && { timeout: 300000 })
  }),
  getVehicleMaintenanceReport: (params) => api.get('/reports/vehicle-maintenance', {
    params: {
      ...params,
      vehicleIds: params.vehicleIds?.length ? params.vehicleIds.join(',') : undefined
    },
    responseType: ['pdf', 'csv', 'xlsx'].includes(params.format) ? 'blob' : 'json',
    ...(['pdf', 'csv', 'xlsx'].includes(params.format) && { timeout: 300000 })
  }),
  getViolationsReport: (params) => api.get('/reports/violations', {
    params: {
      ...params,
      driverIds: params.driverIds?.length ? params.driverIds.join(',') : undefined,
      vehicleIds: params.vehicleIds?.length ? params.vehicleIds.join(',') : undefined
    },
    responseType: ['pdf', 'csv', 'xlsx'].includes(params.format) ? 'blob' : 'json',
    ...(['pdf', 'csv', 'xlsx'].includes(params.format) && { timeout: 300000 })
  }),
  getAuditReport: (params) => api.get('/reports/audit', {
    params,
    responseType: ['pdf', 'csv', 'xlsx'].includes(params.format) ? 'blob' : 'json',
    ...(['pdf', 'csv', 'xlsx'].includes(params.format) && { timeout: 300000 })
  })
};
```

Key points:
- Only include driverIds/vehicleIds in params if array has items (use `?.length` check)
- Use `undefined` not empty string to omit param entirely from query string
- Audit report unchanged (no entity filters)
  </action>
  <verify>
Check that api.js has the updated reportsAPI with array serialization logic:
```bash
grep -A 5 "driverIds" frontend/src/utils/api.js
```
Should show `.join(',')` pattern.
  </verify>
  <done>
reportsAPI methods serialize driverIds and vehicleIds arrays to comma-separated strings when arrays have items, and omit params when empty.
  </done>
</task>

</tasks>

<verification>
1. datePresets.js exists with getDatePresets and getActivePreset exports
2. reportFilterConfig.js exists with REPORT_FILTER_CONFIG for all 4 report types
3. Backend reports.js handles driverIds, vehicleIds, complianceStatus, status query params
4. Frontend api.js serializes arrays to comma-separated strings
5. No lint errors in modified files
</verification>

<success_criteria>
- Date presets calculate correct date ranges using date-fns
- Report filter config defines correct options per report type
- Backend filters work with multi-select IDs
- Frontend API properly serializes filter params
- Backward compatibility maintained for single-item filters
</success_criteria>

<output>
After completion, create `.planning/phases/09-unified-filtering/09-01-SUMMARY.md`
</output>
