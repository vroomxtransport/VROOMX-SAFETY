---
phase: 04-entity-linking
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/routes/violations.js
  - frontend/src/utils/api.js
autonomous: true

must_haves:
  truths:
    - "API endpoint returns violations needing manual review"
    - "Review queue excludes violations without unitInfo"
    - "Review queue is company-scoped (multi-tenancy)"
    - "Frontend API client can fetch review queue"
  artifacts:
    - path: "backend/routes/violations.js"
      provides: "GET /api/violations/review-queue endpoint"
      contains: "review-queue"
    - path: "frontend/src/utils/api.js"
      provides: "violationsAPI.getReviewQueue method"
      contains: "getReviewQueue"
  key_links:
    - from: "backend/routes/violations.js"
      to: "backend/models/Violation.js"
      via: "Violation.find with reviewRequired filter"
      pattern: "linkingMetadata\\.reviewRequired.*true"
---

<objective>
Create the API endpoint that returns violations flagged for manual review, enabling users to confirm uncertain entity matches.

Purpose: When the linking service encounters partial matches (fuzzy unit number at 70-89% confidence), it flags them for review. This plan creates the endpoint that Phase 7 (Polish) will use to build the review queue UI.

Output: New GET /api/violations/review-queue endpoint and frontend API client method.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-entity-linking/04-01-PLAN.md

# Files to modify
@backend/routes/violations.js
@frontend/src/utils/api.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add review queue endpoint to violations routes</name>
  <files>backend/routes/violations.js</files>
  <action>
Add a new GET endpoint for fetching violations that need manual review.

**IMPORTANT:** Add this route BEFORE any /:id routes (Express matches top-to-bottom, so named routes must come first).

**Route Definition:**
```javascript
// GET /api/violations/review-queue - Get violations needing manual entity linking review
router.get('/review-queue', protect, restrictToCompany, asyncHandler(async (req, res) => {
  const { page = 1, limit = 50 } = req.query;
  const skip = (parseInt(page) - 1) * parseInt(limit);

  // Find violations flagged for review that have unitInfo data
  // (violations without unitInfo should never be in review queue - nothing to match)
  const query = {
    ...req.companyFilter,
    'linkingMetadata.reviewRequired': true,
    // Must have at least some unitInfo to be reviewable
    $or: [
      { 'unitInfo.driverLicense': { $exists: true, $ne: null } },
      { 'unitInfo.vehicleVIN': { $exists: true, $ne: null } },
      { 'unitInfo.unitNumber': { $exists: true, $ne: null } },
      { 'unitInfo.vehicleLicense': { $exists: true, $ne: null } }
    ]
  };

  const [violations, total] = await Promise.all([
    Violation.find(query)
      .populate('driverId', 'firstName lastName cdl.number')
      .populate('vehicleId', 'unitNumber vin')
      .sort({ violationDate: -1 })
      .skip(skip)
      .limit(parseInt(limit))
      .lean(),
    Violation.countDocuments(query)
  ]);

  // Add unitInfo from FMCSAInspection if available
  const FMCSAInspection = require('../models/FMCSAInspection');
  const enhancedViolations = await Promise.all(
    violations.map(async (violation) => {
      // Check if violation has inspectionNumber to look up unitInfo
      if (violation.inspectionNumber) {
        const inspection = await FMCSAInspection.findOne({
          companyId: violation.companyId,
          reportNumber: violation.inspectionNumber
        }).select('unitInfo').lean();

        if (inspection?.unitInfo) {
          violation.unitInfo = inspection.unitInfo;
        }
      }
      return violation;
    })
  );

  res.json({
    violations: enhancedViolations,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit),
      total,
      pages: Math.ceil(total / parseInt(limit))
    }
  });
}));
```

**Wait** - looking at the Violation model, I see unitInfo is NOT on the Violation model itself. The research indicates unitInfo comes from FMCSAInspection. Let me revise:

Actually, the query needs to find violations where:
1. linkingMetadata.reviewRequired is true
2. There's a matching FMCSAInspection with unitInfo

**Simpler approach** - just filter by reviewRequired and let the frontend filter out useless items:

```javascript
// GET /api/violations/review-queue - Get violations needing manual entity linking review
router.get('/review-queue', protect, restrictToCompany, asyncHandler(async (req, res) => {
  const { page = 1, limit = 50 } = req.query;
  const skip = (parseInt(page) - 1) * parseInt(limit);

  const query = {
    ...req.companyFilter,
    'linkingMetadata.reviewRequired': true
  };

  const [violations, total] = await Promise.all([
    Violation.find(query)
      .populate('driverId', 'firstName lastName cdl.number cdl.state')
      .populate('vehicleId', 'unitNumber vin licensePlate')
      .sort({ violationDate: -1 })
      .skip(skip)
      .limit(parseInt(limit))
      .lean(),
    Violation.countDocuments(query)
  ]);

  // Fetch unitInfo from FMCSAInspection for each violation
  const FMCSAInspection = require('../models/FMCSAInspection');
  const enhancedViolations = await Promise.all(
    violations.map(async (v) => {
      if (v.inspectionNumber) {
        const inspection = await FMCSAInspection.findOne({
          companyId: v.companyId,
          reportNumber: v.inspectionNumber
        }).select('unitInfo').lean();
        v.unitInfo = inspection?.unitInfo || null;
      }
      return v;
    })
  );

  res.json({
    violations: enhancedViolations,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit),
      total,
      pages: Math.ceil(total / parseInt(limit))
    }
  });
}));
```

**Key requirements:**
- Uses protect + restrictToCompany middleware (company-scoped)
- Filters by linkingMetadata.reviewRequired: true
- Populates driverId and vehicleId with key fields for display
- Fetches unitInfo from FMCSAInspection via inspectionNumber lookup
- Supports pagination with page/limit query params
- Returns violations array and pagination object

**Placement:** Add BEFORE the `/:id` route definition to ensure Express matches it correctly.
  </action>
  <verify>
1. Route exists: `grep "review-queue" backend/routes/violations.js`
2. Uses company filter: `grep "companyFilter" backend/routes/violations.js | grep -c review`
3. Filters by reviewRequired: `grep "reviewRequired" backend/routes/violations.js`
  </verify>
  <done>
- GET /api/violations/review-queue endpoint added before /:id routes
- Uses protect + restrictToCompany middleware
- Filters by linkingMetadata.reviewRequired: true
- Populates driver and vehicle references
- Fetches unitInfo from FMCSAInspection
- Returns pagination metadata
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getReviewQueue to frontend API client</name>
  <files>frontend/src/utils/api.js</files>
  <action>
Add a new method to violationsAPI in the frontend API client.

Find the violationsAPI object (search for `const violationsAPI` or `violationsAPI =`) and add:

```javascript
getReviewQueue: (params = {}) => api.get('/violations/review-queue', { params }),
```

This follows the existing pattern in api.js where API methods accept optional params objects.

The params object can include:
- page: number (default 1)
- limit: number (default 50)

**Example usage (for future Phase 7):**
```javascript
const { data } = await violationsAPI.getReviewQueue({ page: 1, limit: 25 });
// data.violations - array of violations needing review
// data.pagination - { page, limit, total, pages }
```
  </action>
  <verify>Run `grep "getReviewQueue" frontend/src/utils/api.js` - should show the method definition</verify>
  <done>violationsAPI.getReviewQueue method exists, accepts optional params object</done>
</task>

</tasks>

<verification>
1. Backend endpoint exists: `grep -B 2 -A 5 "review-queue" backend/routes/violations.js`
2. Frontend method exists: `grep "getReviewQueue" frontend/src/utils/api.js`
3. Route is before /:id: Check that review-queue appears before any `/:id` pattern in violations.js
</verification>

<success_criteria>
- [ ] GET /api/violations/review-queue endpoint added
- [ ] Route placed BEFORE /:id routes
- [ ] Endpoint uses protect + restrictToCompany middleware
- [ ] Filters by linkingMetadata.reviewRequired: true
- [ ] Populates driverId with firstName, lastName, cdl.number, cdl.state
- [ ] Populates vehicleId with unitNumber, vin, licensePlate
- [ ] Fetches unitInfo from FMCSAInspection via inspectionNumber
- [ ] Returns pagination: { page, limit, total, pages }
- [ ] violationsAPI.getReviewQueue method added to frontend
</success_criteria>

<output>
After completion, create `.planning/phases/04-entity-linking/04-03-SUMMARY.md`
</output>
