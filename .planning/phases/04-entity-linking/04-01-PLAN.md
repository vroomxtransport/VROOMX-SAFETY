---
phase: 04-entity-linking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/services/entityLinkingService.js
autonomous: true

must_haves:
  truths:
    - "Violations with CDL numbers are linked to drivers with 100% confidence"
    - "Violations with VIN are linked to vehicles with 100% confidence"
    - "Violations with unit numbers are linked via fuzzy match with 70-95% confidence"
    - "Violations already manually linked are never re-linked"
    - "Violations without unitInfo are skipped (no error)"
  artifacts:
    - path: "backend/services/entityLinkingService.js"
      provides: "Entity linking service with driver/vehicle matching"
      exports: ["linkViolationsForCompany", "linkToDriver", "linkToVehicle"]
      min_lines: 150
  key_links:
    - from: "backend/services/entityLinkingService.js"
      to: "backend/models/Driver.js"
      via: "Driver.findOne by cdl.number"
      pattern: "Driver\\.findOne.*cdl\\.number"
    - from: "backend/services/entityLinkingService.js"
      to: "backend/models/Vehicle.js"
      via: "Vehicle.findOne by vin"
      pattern: "Vehicle\\.findOne.*vin"
    - from: "backend/services/entityLinkingService.js"
      to: "backend/models/Violation.js"
      via: "Violation.updateOne to set linkingMetadata"
      pattern: "Violation\\.updateOne.*linkingMetadata"
---

<objective>
Create the entity linking service that matches violations to drivers and vehicles using CDL numbers, VINs, and fuzzy unit number matching.

Purpose: This is the core matching logic for Phase 4. Violations synced from FMCSA contain driver/vehicle identifiers (CDL, VIN, unit number) in their unitInfo field. This service matches those identifiers to existing Driver and Vehicle records, storing confidence scores in linkingMetadata.

Output: A new backend/services/entityLinkingService.js with tiered matching (exact CDL/VIN first, fuzzy unit number second) and confidence scoring.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-entity-linking/04-RESEARCH.md

# Source files to understand patterns
@backend/services/fmcsaSyncOrchestrator.js
@backend/models/Violation.js
@backend/models/Driver.js
@backend/models/Vehicle.js
@backend/models/FMCSAInspection.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install fuzzball dependency</name>
  <files>backend/package.json</files>
  <action>
Install fuzzball for fuzzy string matching:

```bash
cd backend && npm install fuzzball
```

fuzzball is a port of Python's fuzzywuzzy library and provides token_sort_ratio which handles word reordering (e.g., "Unit 123" matches "123 Unit").

Do NOT install any other fuzzy matching libraries (not Fuse.js, not fast-fuzzy).
  </action>
  <verify>Run `grep fuzzball backend/package.json` - should show fuzzball in dependencies</verify>
  <done>fuzzball appears in backend/package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create entityLinkingService with driver and vehicle matching</name>
  <files>backend/services/entityLinkingService.js</files>
  <action>
Create backend/services/entityLinkingService.js following the orchestrator pattern from fmcsaSyncOrchestrator.js.

**Threshold Configuration:**
```javascript
const THRESHOLDS = {
  EXACT: 100,      // Exact CDL/VIN match
  HIGH: 90,        // Auto-link with high confidence
  MEDIUM: 70,      // Auto-link but flag reviewRequired
  REJECT: 50       // Below this, don't link
};
```

**Service Structure:**
```javascript
const entityLinkingService = {
  // Main entry point - called after sync
  async linkViolationsForCompany(companyId) { ... },

  // Driver matching - CDL exact match only
  async linkToDriver(violation, companyId) { ... },

  // Vehicle matching - VIN exact, then unit number fuzzy
  async linkToVehicle(violation, companyId) { ... }
};
```

**linkViolationsForCompany Logic:**
1. Find violations where:
   - companyId matches
   - AND (driverId is null OR vehicleId is null)
   - AND linkingMetadata.linkingMethod is NOT 'manual' (preserve user corrections)
   - Limit to 1000 per batch
2. For each violation:
   - Skip if no unitInfo at all (DataHub violations have no unitInfo - expected, not an error)
   - Call linkToDriver if driverId is null
   - Call linkToVehicle if vehicleId is null
   - Update violation with results
3. Return results: { linked: N, reviewRequired: N, skipped: N }

**linkToDriver Logic (CDL exact match only):**
1. Check if violation.unitInfo?.driverLicense exists
   - If not, return { driverId: null, confidence: 0, method: null }
2. Normalize CDL: `cdl.toUpperCase().trim()`
3. Try exact match with state:
   ```javascript
   Driver.findOne({
     companyId,
     'cdl.number': normalizedCdl,
     'cdl.state': violation.unitInfo.driverState?.toUpperCase()
   })
   ```
   - If found: return { driverId, confidence: 100, method: 'cdl_exact' }
4. Try exact match without state (lower confidence):
   ```javascript
   Driver.findOne({ companyId, 'cdl.number': normalizedCdl })
   ```
   - If found: return { driverId, confidence: 95, method: 'cdl_exact' }
5. If no match found and driverLicense was provided:
   - Return { driverId: null, confidence: 0, method: null, reviewRequired: true }
   - (Only flag reviewRequired when there WAS data to match but it failed)

**linkToVehicle Logic (VIN exact, then unit number fuzzy):**
1. Try VIN exact match first:
   - If violation.unitInfo?.vehicleVIN exists
   - Normalize: `vin.toUpperCase().trim()`
   - `Vehicle.findOne({ companyId, vin: normalizedVin })`
   - If found: return { vehicleId, confidence: 100, method: 'vin_exact' }

2. Try unit number fuzzy match:
   - If violation.unitInfo?.unitNumber exists
   - Load all vehicles for company: `Vehicle.find({ companyId }).select('_id unitNumber').lean()`
   - Use fuzzball.token_sort_ratio to compare (handles word reordering)
   - Track best match and score
   - If score >= THRESHOLDS.HIGH (90): return { vehicleId, confidence: score, method: 'unit_number' }
   - If score >= THRESHOLDS.MEDIUM (70): return { vehicleId, confidence: score, method: 'unit_number', reviewRequired: true }

3. Try license plate match as fallback:
   - If violation.unitInfo?.vehicleLicense AND vehicleState exist
   - `Vehicle.findOne({ companyId, 'licensePlate.number': license, 'licensePlate.state': state })`
   - If found: return { vehicleId, confidence: 95, method: 'license_plate' }

4. If no match and there was unitInfo data:
   - Return { vehicleId: null, confidence: 0, method: null, reviewRequired: true }

**Violation Update Logic:**
After getting driver and vehicle results, update the violation:
```javascript
const updates = {
  'linkingMetadata.linkedAt': new Date()
};

if (driverResult.driverId) {
  updates.driverId = driverResult.driverId;
  updates['linkingMetadata.driverConfidence'] = driverResult.confidence;
  updates['linkingMetadata.linkingMethod'] = driverResult.method;
}

if (vehicleResult.vehicleId) {
  updates.vehicleId = vehicleResult.vehicleId;
  updates['linkingMetadata.vehicleConfidence'] = vehicleResult.confidence;
  // Only set method if not already set by driver linking
  if (!updates['linkingMetadata.linkingMethod']) {
    updates['linkingMetadata.linkingMethod'] = vehicleResult.method;
  }
}

const requiresReview = driverResult.reviewRequired || vehicleResult.reviewRequired;
updates['linkingMetadata.reviewRequired'] = requiresReview;

await Violation.updateOne({ _id: violation._id }, { $set: updates });
```

**Error Handling:**
- Wrap each violation processing in try/catch
- Log errors but continue processing other violations
- Never throw from public methods (safe for orchestrator/cron usage)
- Use console.log prefix: `[Entity Linking]`

**Critical Requirements:**
- ALWAYS normalize to uppercase before comparison (CDL, VIN, unit numbers)
- NEVER re-link violations where linkingMethod is 'manual'
- NEVER log errors for violations without unitInfo (expected for DataHub imports)
- Only set reviewRequired: true when there IS partial data suggesting a possible match
  </action>
  <verify>
1. File exists: `ls backend/services/entityLinkingService.js`
2. Exports correct methods: `grep -E "linkViolationsForCompany|linkToDriver|linkToVehicle" backend/services/entityLinkingService.js`
3. Uses fuzzball: `grep "require.*fuzzball" backend/services/entityLinkingService.js`
4. Skips manual links: `grep "manual" backend/services/entityLinkingService.js`
5. Normalizes case: `grep "toUpperCase" backend/services/entityLinkingService.js`
  </verify>
  <done>
- entityLinkingService.js exports linkViolationsForCompany, linkToDriver, linkToVehicle
- CDL exact matching with 100%/95% confidence
- VIN exact matching with 100% confidence
- Unit number fuzzy matching with fuzzball.token_sort_ratio
- License plate fallback matching with 95% confidence
- Manual links preserved (linkingMethod: 'manual' skipped)
- reviewRequired only set when partial unitInfo exists
  </done>
</task>

</tasks>

<verification>
1. fuzzball installed: `cd backend && npm ls fuzzball`
2. Service file exists and exports correctly: `node -e "const s = require('./backend/services/entityLinkingService'); console.log(Object.keys(s))"`
3. Service can be instantiated without errors (no missing requires)
</verification>

<success_criteria>
- [ ] fuzzball in backend/package.json dependencies
- [ ] entityLinkingService.js created with ~150+ lines
- [ ] Exports: linkViolationsForCompany, linkToDriver, linkToVehicle
- [ ] Uses fuzzball.token_sort_ratio for unit number matching
- [ ] CDL matching normalizes to uppercase
- [ ] VIN matching normalizes to uppercase
- [ ] Manual links (linkingMethod: 'manual') are never re-linked
- [ ] reviewRequired only set when unitInfo exists but match fails
- [ ] Console logging uses [Entity Linking] prefix
- [ ] Never throws from public methods
</success_criteria>

<output>
After completion, create `.planning/phases/04-entity-linking/04-01-SUMMARY.md`
</output>
