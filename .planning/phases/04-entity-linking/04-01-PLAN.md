---
phase: 04-entity-linking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/services/entityLinkingService.js
autonomous: true

must_haves:
  truths:
    - "Violations with CDL numbers are linked to drivers with 100% confidence"
    - "Violations with license plate data are linked to vehicles with 95% confidence"
    - "Violations already manually linked are never re-linked"
    - "Violations without unitInfo are skipped (no error)"
  artifacts:
    - path: "backend/services/entityLinkingService.js"
      provides: "Entity linking service with driver/vehicle matching"
      exports: ["linkViolationsForCompany", "linkToDriver", "linkToVehicle"]
      min_lines: 120
  key_links:
    - from: "backend/services/entityLinkingService.js"
      to: "backend/models/Driver.js"
      via: "Driver.findOne by cdl.number"
      pattern: "Driver\\.findOne.*cdl\\.number"
    - from: "backend/services/entityLinkingService.js"
      to: "backend/models/Vehicle.js"
      via: "Vehicle.findOne by licensePlate.number + licensePlate.state"
      pattern: "Vehicle\\.findOne.*licensePlate\\.number"
    - from: "backend/services/entityLinkingService.js"
      to: "backend/models/Violation.js"
      via: "Violation.updateOne to set linkingMetadata"
      pattern: "Violation\\.updateOne.*linkingMetadata"
---

<objective>
Create the entity linking service that matches violations to drivers and vehicles using CDL numbers and license plate data.

Purpose: This is the core matching logic for Phase 4. Violations synced from FMCSA contain driver/vehicle identifiers (CDL, license plate) in their unitInfo field. This service matches those identifiers to existing Driver and Vehicle records, storing confidence scores in linkingMetadata.

Output: A new backend/services/entityLinkingService.js with exact matching (CDL for drivers, license plate for vehicles) and confidence scoring.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-entity-linking/04-RESEARCH.md

# Source files to understand patterns
@backend/services/fmcsaSyncOrchestrator.js
@backend/models/Violation.js
@backend/models/Driver.js
@backend/models/Vehicle.js
@backend/models/FMCSAInspection.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install fuzzball dependency</name>
  <files>backend/package.json</files>
  <action>
Install fuzzball for fuzzy string matching:

```bash
cd backend && npm install fuzzball
```

fuzzball is a port of Python's fuzzywuzzy library and provides token_sort_ratio which handles word reordering. While NOT currently used in the entity linking service (due to schema limitations - no unit number or VIN fields in unitInfo), it is installed for potential future use if the schema is extended.

Do NOT install any other fuzzy matching libraries (not Fuse.js, not fast-fuzzy).
  </action>
  <verify>Run `grep fuzzball backend/package.json` - should show fuzzball in dependencies</verify>
  <done>fuzzball appears in backend/package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create entityLinkingService with driver and vehicle matching</name>
  <files>backend/services/entityLinkingService.js</files>
  <action>
Create backend/services/entityLinkingService.js following the orchestrator pattern from fmcsaSyncOrchestrator.js.

**IMPORTANT SCHEMA CONSTRAINT:** The FMCSAInspection.unitInfo schema only contains:
- vehicleType: String
- vehicleLicense: String (license plate number)
- vehicleState: String (license plate state)
- driverLicense: String (CDL number)
- driverState: String (CDL state)

There is NO vehicleVIN or unitNumber field. Vehicle matching can ONLY use license plate.

**Threshold Configuration:**
```javascript
const THRESHOLDS = {
  EXACT: 100,      // Exact CDL match with state
  HIGH: 95,        // Exact CDL match without state, or license plate match
  MEDIUM: 70,      // Reserved for future fuzzy matching
  REJECT: 50       // Below this, don't link
};
```

**Service Structure:**
```javascript
const entityLinkingService = {
  // Main entry point - called after sync
  async linkViolationsForCompany(companyId) { ... },

  // Driver matching - CDL exact match only
  async linkToDriver(violation, companyId) { ... },

  // Vehicle matching - license plate only (no VIN or unit number in schema)
  async linkToVehicle(violation, companyId) { ... }
};
```

**linkViolationsForCompany Logic:**
1. Find violations where:
   - companyId matches
   - AND (driverId is null OR vehicleId is null)
   - AND linkingMetadata.linkingMethod is NOT 'manual' (preserve user corrections)
   - Limit to 1000 per batch
2. For each violation:
   - Skip if no unitInfo at all (DataHub violations have no unitInfo - expected, not an error)
   - Call linkToDriver if driverId is null
   - Call linkToVehicle if vehicleId is null
   - Update violation with results
3. Return results: { linked: N, reviewRequired: N, skipped: N }

**linkToDriver Logic (CDL exact match only):**
1. Check if violation.unitInfo?.driverLicense exists
   - If not, return { driverId: null, confidence: 0, method: null }
2. Normalize CDL: `cdl.toUpperCase().trim()`
3. Try exact match with state:
   ```javascript
   Driver.findOne({
     companyId,
     'cdl.number': normalizedCdl,
     'cdl.state': violation.unitInfo.driverState?.toUpperCase()
   })
   ```
   - If found: return { driverId, confidence: 100, method: 'cdl_exact' }
4. Try exact match without state (lower confidence):
   ```javascript
   Driver.findOne({ companyId, 'cdl.number': normalizedCdl })
   ```
   - If found: return { driverId, confidence: 95, method: 'cdl_exact' }
5. If no match found and driverLicense was provided:
   - Return { driverId: null, confidence: 0, method: null, reviewRequired: true }
   - (Only flag reviewRequired when there WAS data to match but it failed)

**linkToVehicle Logic (license plate match ONLY):**
1. Check if violation.unitInfo?.vehicleLicense AND vehicleState exist
   - If not, return { vehicleId: null, confidence: 0, method: null }
   - (Cannot match without both license number and state)
2. Normalize values:
   ```javascript
   const licensePlate = violation.unitInfo.vehicleLicense.toUpperCase().trim();
   const plateState = violation.unitInfo.vehicleState.toUpperCase().trim();
   ```
3. Try exact match:
   ```javascript
   Vehicle.findOne({
     companyId,
     'licensePlate.number': licensePlate,
     'licensePlate.state': plateState
   })
   ```
   - If found: return { vehicleId, confidence: 95, method: 'license_plate' }
4. If no match found and vehicleLicense was provided:
   - Return { vehicleId: null, confidence: 0, method: null, reviewRequired: true }

**NOTE:** No VIN matching or unit number fuzzy matching is implemented because:
- FMCSAInspection.unitInfo does NOT contain vehicleVIN field
- FMCSAInspection.unitInfo does NOT contain unitNumber field
- The only vehicle identifiers available are vehicleLicense and vehicleState

**Violation Update Logic:**
After getting driver and vehicle results, update the violation:
```javascript
const updates = {
  'linkingMetadata.linkedAt': new Date()
};

if (driverResult.driverId) {
  updates.driverId = driverResult.driverId;
  updates['linkingMetadata.driverConfidence'] = driverResult.confidence;
  updates['linkingMetadata.linkingMethod'] = driverResult.method;
}

if (vehicleResult.vehicleId) {
  updates.vehicleId = vehicleResult.vehicleId;
  updates['linkingMetadata.vehicleConfidence'] = vehicleResult.confidence;
  // Only set method if not already set by driver linking
  if (!updates['linkingMetadata.linkingMethod']) {
    updates['linkingMetadata.linkingMethod'] = vehicleResult.method;
  }
}

const requiresReview = driverResult.reviewRequired || vehicleResult.reviewRequired;
updates['linkingMetadata.reviewRequired'] = requiresReview;

await Violation.updateOne({ _id: violation._id }, { $set: updates });
```

**Error Handling:**
- Wrap each violation processing in try/catch
- Log errors but continue processing other violations
- Never throw from public methods (safe for orchestrator/cron usage)
- Use console.log prefix: `[Entity Linking]`

**Critical Requirements:**
- ALWAYS normalize to uppercase before comparison (CDL, license plate)
- NEVER re-link violations where linkingMethod is 'manual'
- NEVER log errors for violations without unitInfo (expected for DataHub imports)
- Only set reviewRequired: true when there IS partial data suggesting a possible match
- Do NOT attempt VIN matching (field doesn't exist in schema)
- Do NOT attempt unit number fuzzy matching (field doesn't exist in schema)
  </action>
  <verify>
1. File exists: `ls backend/services/entityLinkingService.js`
2. Exports correct methods: `grep -E "linkViolationsForCompany|linkToDriver|linkToVehicle" backend/services/entityLinkingService.js`
3. Uses license plate matching: `grep "licensePlate" backend/services/entityLinkingService.js`
4. Skips manual links: `grep "manual" backend/services/entityLinkingService.js`
5. Normalizes case: `grep "toUpperCase" backend/services/entityLinkingService.js`
6. Does NOT reference vehicleVIN: `grep -c "vehicleVIN" backend/services/entityLinkingService.js` should return 0
7. Does NOT reference unitNumber: `grep -c "unitNumber" backend/services/entityLinkingService.js` should return 0
  </verify>
  <done>
- entityLinkingService.js exports linkViolationsForCompany, linkToDriver, linkToVehicle
- CDL exact matching with 100%/95% confidence (with/without state)
- License plate matching with 95% confidence (only vehicle matching method available)
- Manual links preserved (linkingMethod: 'manual' skipped)
- reviewRequired only set when partial unitInfo exists
- NO VIN matching (field doesn't exist in schema)
- NO unit number fuzzy matching (field doesn't exist in schema)
  </done>
</task>

</tasks>

<verification>
1. fuzzball installed: `cd backend && npm ls fuzzball`
2. Service file exists and exports correctly: `node -e "const s = require('./backend/services/entityLinkingService'); console.log(Object.keys(s))"`
3. Service can be instantiated without errors (no missing requires)
4. Service does NOT reference non-existent fields: `grep -E "vehicleVIN|unitNumber" backend/services/entityLinkingService.js` should return nothing
</verification>

<success_criteria>
- [ ] fuzzball in backend/package.json dependencies (for future use)
- [ ] entityLinkingService.js created with ~120+ lines
- [ ] Exports: linkViolationsForCompany, linkToDriver, linkToVehicle
- [ ] CDL matching normalizes to uppercase
- [ ] License plate matching normalizes to uppercase
- [ ] Manual links (linkingMethod: 'manual') are never re-linked
- [ ] reviewRequired only set when unitInfo exists but match fails
- [ ] Console logging uses [Entity Linking] prefix
- [ ] Never throws from public methods
- [ ] Does NOT reference vehicleVIN (doesn't exist in schema)
- [ ] Does NOT reference unitNumber (doesn't exist in schema)
</success_criteria>

<output>
After completion, create `.planning/phases/04-entity-linking/04-01-SUMMARY.md`
</output>
