---
phase: 10-fmcsa-compliance-reports
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - backend/routes/reports.js
  - frontend/src/utils/api.js
  - frontend/src/pages/Reports.jsx
  - frontend/src/utils/reportFilterConfig.js
autonomous: true

must_haves:
  truths:
    - "User can generate DataQ Challenge History Report"
    - "DataQ report shows challenge submissions, outcomes, and success rate"
    - "DataQ report shows estimated CSA points saved from accepted challenges"
    - "User can generate Accident Summary Report"
    - "Accident report shows DOT reportable status, injuries, fatalities, and costs"
    - "User can generate Maintenance Cost Report"
    - "Maintenance report shows spending by vehicle, category, and vendor"
  artifacts:
    - path: "backend/routes/reports.js"
      provides: "DataQ, Accident, and Maintenance Cost report endpoints"
      contains: "dataq-history"
    - path: "frontend/src/pages/Reports.jsx"
      provides: "Report cards for all new report types"
      contains: "DataQ Challenge"
  key_links:
    - from: "backend/routes/reports.js"
      to: "Violation.dataQChallenge"
      via: "challenge status aggregation"
      pattern: "dataQChallenge\\.submitted.*true"
    - from: "backend/routes/reports.js"
      to: "Accident model"
      via: "DOT recordable filtering"
      pattern: "isDotRecordable"
    - from: "backend/routes/reports.js"
      to: "MaintenanceRecord model"
      via: "MongoDB aggregation pipeline"
      pattern: "\\$group.*totalCost"
---

<objective>
Create three new report endpoints: DataQ Challenge History (with success rates and CSA points saved), Accident Summary (with DOT reportable status and costs), and Maintenance Cost Report (with aggregation by vehicle, category, and vendor).

Purpose: These reports complete the FMCSA compliance reporting suite, enabling carriers to track DataQ challenge effectiveness, accident history for safety audits, and maintenance spending for budget analysis.
Output: Three new report endpoints with full JSON/CSV/Excel/PDF support and frontend integration.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-fmcsa-compliance-reports/10-RESEARCH.md
@backend/routes/reports.js
@backend/models/Violation.js
@backend/models/Accident.js
@backend/models/MaintenanceRecord.js
@backend/utils/pdfGenerator.js
@backend/services/exportService.js
@frontend/src/utils/api.js
@frontend/src/pages/Reports.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DataQ Challenge History Report endpoint</name>
  <files>backend/routes/reports.js</files>
  <action>
Add new endpoint GET /api/reports/dataq-history:

1. Create endpoint with checkPermission('reports', 'view')
2. Query parameters: format (default 'json'), startDate, endDate, driverIds
3. Implementation:
   ```javascript
   const query = {
     companyId,
     'dataQChallenge.submitted': true
   };

   if (startDate || endDate) {
     query['dataQChallenge.submissionDate'] = {};
     if (startDate) query['dataQChallenge.submissionDate'].$gte = new Date(startDate);
     if (endDate) query['dataQChallenge.submissionDate'].$lte = new Date(endDate);
   }

   if (driverIds) {
     const ids = driverIds.split(',').filter(Boolean);
     if (ids.length > 0) query.driverId = { $in: ids };
   }

   const violations = await Violation.find(query)
     .populate('driverId', 'firstName lastName')
     .sort('-dataQChallenge.submissionDate')
     .lean();
   ```

4. Map challenges and calculate metrics:
   ```javascript
   const challenges = violations.map(v => ({
     inspectionNumber: v.inspectionNumber,
     violationType: v.violationType,
     violationDate: v.violationDate,
     basic: v.basic,
     severityWeight: v.severityWeight,
     submissionDate: v.dataQChallenge.submissionDate,
     caseNumber: v.dataQChallenge.caseNumber,
     challengeType: v.dataQChallenge.challengeType,
     status: v.dataQChallenge.status,
     responseDate: v.dataQChallenge.responseDate,
     driverName: v.driverId ? `${v.driverId.firstName} ${v.driverId.lastName}` : null,
     csaPointsSaved: v.dataQChallenge.status === 'accepted' ? v.severityWeight : 0
   }));

   const accepted = challenges.filter(c => c.status === 'accepted');
   const denied = challenges.filter(c => c.status === 'denied');
   const pending = challenges.filter(c => ['pending', 'under_review'].includes(c.status));
   const withdrawn = challenges.filter(c => c.status === 'withdrawn');

   // Success rate: accepted / (accepted + denied) - exclude pending/withdrawn
   const resolved = accepted.length + denied.length;
   const successRate = resolved > 0 ? Math.round((accepted.length / resolved) * 100) : 0;
   const totalCsaPointsSaved = challenges.reduce((sum, c) => sum + c.csaPointsSaved, 0);
   ```

5. JSON response:
   ```javascript
   {
     success: true,
     report: {
       type: 'DataQ Challenge History Report',
       generatedAt: new Date(),
       company: { name, dotNumber },
       summary: {
         totalSubmissions: challenges.length,
         accepted: accepted.length,
         denied: denied.length,
         pending: pending.length,
         withdrawn: withdrawn.length,
         successRate,
         estimatedCsaPointsSaved: totalCsaPointsSaved
       },
       challenges
     }
   }
   ```

6. CSV/Excel: Flatten challenges with all fields plus csaPointsSaved
7. PDF:
   - Summary box: Total, Accepted, Success Rate, Est. CSA Points Saved
   - Table: Challenge details with status, outcome, points
   - Note at bottom: "CSA points saved is an estimate based on severity weight"
  </action>
  <verify>
    - curl -X GET "http://localhost:5001/api/reports/dataq-history?format=json" returns challenges with success rate
    - successRate is a number 0-100, not NaN
    - estimatedCsaPointsSaved sums correctly
  </verify>
  <done>
    - GET /api/reports/dataq-history endpoint returns challenge history
    - Shows submissions, outcomes, success rate (NRPT-01, NRPT-02)
    - Shows estimated CSA points saved (NRPT-03)
    - Supports all formats and date/driver filters
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Accident Summary Report endpoint</name>
  <files>backend/routes/reports.js</files>
  <action>
Add new endpoint GET /api/reports/accident-summary:

1. Create endpoint with checkPermission('reports', 'view')
2. Query parameters: format, startDate, endDate, driverIds, vehicleIds
3. Implementation:
   ```javascript
   const query = { companyId };

   if (startDate || endDate) {
     query.accidentDate = {};
     if (startDate) query.accidentDate.$gte = new Date(startDate);
     if (endDate) query.accidentDate.$lte = new Date(endDate);
   }

   if (driverIds) {
     const ids = driverIds.split(',').filter(Boolean);
     if (ids.length > 0) query.driverId = { $in: ids };
   }
   if (vehicleIds) {
     const ids = vehicleIds.split(',').filter(Boolean);
     if (ids.length > 0) query.vehicleId = { $in: ids };
   }

   const accidents = await Accident.find(query)
     .populate('driverId', 'firstName lastName')
     .populate('vehicleId', 'unitNumber')
     .sort('-accidentDate')
     .lean();
   ```

4. Calculate summary metrics:
   ```javascript
   const dotReportable = accidents.filter(a => a.isDotRecordable);
   const fatalities = accidents.filter(a => a.recordableCriteria?.fatality);
   const injuries = accidents.filter(a => a.recordableCriteria?.injury && !a.recordableCriteria?.fatality);
   const towAways = accidents.filter(a =>
     a.recordableCriteria?.towAway &&
     !a.recordableCriteria?.fatality &&
     !a.recordableCriteria?.injury
   );

   // Use totalEstimatedCost virtual/field if available, else calculate
   const totalCost = accidents.reduce((sum, a) => {
     const cost = a.totalEstimatedCost ||
       ((a.costs?.vehicleDamage || 0) + (a.costs?.cargoDamage || 0) + (a.costs?.propertyDamage || 0));
     return sum + cost;
   }, 0);

   const totalInjuries = accidents.reduce((sum, a) => sum + (a.injuries?.length || 0), 0);
   const totalFatalities = accidents.reduce((sum, a) =>
     sum + (a.injuries?.filter(i => i.severity === 'fatal').length || 0), 0);
   ```

5. JSON response with summary and accident list
6. CSV/Excel columns: Date, Location, Driver, Vehicle, DOT Reportable, Severity, Type, Injuries, Fatalities, Est. Cost
7. PDF:
   - Summary box: Total Accidents, DOT Reportable, Total Injuries, Total Fatalities, Total Cost
   - Section: By recordable criteria (Fatalities, Injuries, Tow-aways)
   - Table: Accident details
   - Cost formatted as currency ($X,XXX.XX)
  </action>
  <verify>
    - curl -X GET "http://localhost:5001/api/reports/accident-summary?format=json" returns accident data
    - isDotRecordable field properly categorizes accidents
    - totalCost sums correctly without NaN
  </verify>
  <done>
    - GET /api/reports/accident-summary endpoint returns accident history (NRPT-04)
    - Shows DOT reportable status, injuries, fatalities, costs (NRPT-05)
    - Supports all formats and filters
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Maintenance Cost Report endpoint with aggregation</name>
  <files>backend/routes/reports.js</files>
  <action>
Add new endpoint GET /api/reports/maintenance-costs:

1. Import mongoose at the top if not already (needed for ObjectId in aggregation)
2. Create endpoint with checkPermission('reports', 'view')
3. Query parameters: format, startDate, endDate, vehicleIds
4. Use MongoDB aggregation for efficient grouping:
   ```javascript
   const matchStage = {
     companyId: new mongoose.Types.ObjectId(companyId)
   };

   if (startDate || endDate) {
     matchStage.serviceDate = {};
     if (startDate) matchStage.serviceDate.$gte = new Date(startDate);
     if (endDate) matchStage.serviceDate.$lte = new Date(endDate);
   }

   if (vehicleIds) {
     const ids = vehicleIds.split(',').filter(Boolean);
     if (ids.length > 0) {
       matchStage.vehicleId = { $in: ids.map(id => new mongoose.Types.ObjectId(id)) };
     }
   }

   const [byVehicle, byCategory, byVendor, totals] = await Promise.all([
     MaintenanceRecord.aggregate([
       { $match: matchStage },
       { $group: {
           _id: '$vehicleId',
           totalCost: { $sum: '$totalCost' },
           laborCost: { $sum: '$laborCost' },
           partsCost: { $sum: '$partsCost' },
           recordCount: { $sum: 1 }
         }
       },
       { $lookup: {
           from: 'vehicles',
           localField: '_id',
           foreignField: '_id',
           as: 'vehicle'
         }
       },
       { $unwind: { path: '$vehicle', preserveNullAndEmptyArrays: true } },
       { $project: {
           vehicleId: '$_id',
           unitNumber: '$vehicle.unitNumber',
           totalCost: 1,
           laborCost: 1,
           partsCost: 1,
           recordCount: 1
         }
       },
       { $sort: { totalCost: -1 } }
     ]),

     MaintenanceRecord.aggregate([
       { $match: matchStage },
       { $group: {
           _id: '$recordType',
           totalCost: { $sum: '$totalCost' },
           recordCount: { $sum: 1 }
         }
       },
       { $sort: { totalCost: -1 } }
     ]),

     MaintenanceRecord.aggregate([
       { $match: { ...matchStage, 'provider.name': { $exists: true, $ne: '' } } },
       { $group: {
           _id: '$provider.name',
           totalCost: { $sum: '$totalCost' },
           recordCount: { $sum: 1 }
         }
       },
       { $sort: { totalCost: -1 } }
     ]),

     MaintenanceRecord.aggregate([
       { $match: matchStage },
       { $group: {
           _id: null,
           totalCost: { $sum: '$totalCost' },
           laborCost: { $sum: '$laborCost' },
           partsCost: { $sum: '$partsCost' },
           recordCount: { $sum: 1 }
         }
       }
     ])
   ]);

   const summary = totals[0] || { totalCost: 0, laborCost: 0, partsCost: 0, recordCount: 0 };
   ```

5. JSON response with summary, byVehicle, byCategory, byVendor arrays
6. CSV/Excel: Three sheets or sections - By Vehicle, By Category, By Vendor
7. PDF:
   - Summary box: Total Cost, Labor, Parts, Records
   - Three tables: Top 10 by Vehicle, By Category, Top 10 by Vendor
   - Costs formatted as currency
  </action>
  <verify>
    - curl -X GET "http://localhost:5001/api/reports/maintenance-costs?format=json" returns aggregated cost data
    - byVehicle, byCategory, byVendor arrays populated
    - Total cost equals sum of labor + parts (approximately)
  </verify>
  <done>
    - GET /api/reports/maintenance-costs endpoint returns cost aggregations (NRPT-06)
    - Shows spending by vehicle, category, vendor (NRPT-07)
    - Uses efficient MongoDB aggregation pipeline
    - Supports all formats and filters
  </done>
</task>

<task type="auto">
  <name>Task 4: Add frontend integration for all three reports</name>
  <files>frontend/src/utils/api.js, frontend/src/pages/Reports.jsx, frontend/src/utils/reportFilterConfig.js</files>
  <action>
1. In frontend/src/utils/api.js, add to reportsAPI object:
   ```javascript
   getDataQHistoryReport: (params) => api.get('/reports/dataq-history', {
     params: {
       ...params,
       driverIds: params.driverIds?.length ? params.driverIds.join(',') : undefined
     },
     responseType: ['pdf', 'csv', 'xlsx'].includes(params.format) ? 'blob' : 'json',
     ...(['pdf', 'csv', 'xlsx'].includes(params.format) && { timeout: 300000 })
   }),
   getAccidentSummaryReport: (params) => api.get('/reports/accident-summary', {
     params: {
       ...params,
       driverIds: params.driverIds?.length ? params.driverIds.join(',') : undefined,
       vehicleIds: params.vehicleIds?.length ? params.vehicleIds.join(',') : undefined
     },
     responseType: ['pdf', 'csv', 'xlsx'].includes(params.format) ? 'blob' : 'json',
     ...(['pdf', 'csv', 'xlsx'].includes(params.format) && { timeout: 300000 })
   }),
   getMaintenanceCostReport: (params) => api.get('/reports/maintenance-costs', {
     params: {
       ...params,
       vehicleIds: params.vehicleIds?.length ? params.vehicleIds.join(',') : undefined
     },
     responseType: ['pdf', 'csv', 'xlsx'].includes(params.format) ? 'blob' : 'json',
     ...(['pdf', 'csv', 'xlsx'].includes(params.format) && { timeout: 300000 })
   }),
   ```

2. In frontend/src/pages/Reports.jsx, import FiDollarSign from react-icons/fi (for maintenance cost icon), then add three report cards:
   ```javascript
   {
     id: 'dataq-history',
     title: 'DataQ Challenge History',
     description: 'Challenge submissions, outcomes, success rate, and estimated CSA points saved.',
     icon: FiFileText,
     color: 'indigo',
     api: reportsAPI.getDataQHistoryReport
   },
   {
     id: 'accident-summary',
     title: 'Accident Summary',
     description: 'Accident history with DOT reportable status, injuries, fatalities, and costs.',
     icon: FiAlertTriangle,
     color: 'red',
     api: reportsAPI.getAccidentSummaryReport
   },
   {
     id: 'maintenance-costs',
     title: 'Maintenance Cost Report',
     description: 'Spending analysis by vehicle, category, and vendor.',
     icon: FiDollarSign,
     color: 'green',
     api: reportsAPI.getMaintenanceCostReport
   }
   ```

3. In frontend/src/utils/reportFilterConfig.js, add configurations:
   ```javascript
   'dataq-history': {
     enableDateRange: true,
     enableDriverFilter: true,
     enableVehicleFilter: false,
     enableStatusFilter: false
   },
   'accident-summary': {
     enableDateRange: true,
     enableDriverFilter: true,
     enableVehicleFilter: true,
     enableStatusFilter: false
   },
   'maintenance-costs': {
     enableDateRange: true,
     enableDriverFilter: false,
     enableVehicleFilter: true,
     enableStatusFilter: false
   }
   ```
  </action>
  <verify>
    - npm run dev in frontend starts without errors
    - Reports page shows 9 total report cards (4 original + 2 from plan 02 + 3 new)
    - All new cards have appropriate icons and colors
    - Filter configurations match each report's needs
  </verify>
  <done>
    - DataQ Challenge History card visible
    - Accident Summary card visible
    - Maintenance Cost Report card visible
    - All reports downloadable in all formats
    - Filter configurations correct for each report type
  </done>
</task>

</tasks>

<verification>
1. Backend: Test all three new endpoints with curl for all formats
2. DataQ: Generate report - verify success rate calculation and CSA points
3. Accident: Generate report - verify DOT reportable categorization
4. Maintenance: Generate report - verify aggregation by vehicle/category/vendor
5. Frontend: All 9 reports visible and functional on Reports page
</verification>

<success_criteria>
- User can generate DataQ Challenge History Report (NRPT-01)
- DataQ shows submissions, outcomes, success rate (NRPT-02)
- DataQ shows estimated CSA points saved (NRPT-03)
- User can generate Accident Summary Report (NRPT-04)
- Accident shows DOT reportable, injuries, fatalities, costs (NRPT-05)
- User can generate Maintenance Cost Report (NRPT-06)
- Maintenance shows spending by vehicle, category, vendor (NRPT-07)
- All reports include DOT number and timestamp in PDF header (FMCS-08)
- PDF formatting consistent and audit-ready (FMCS-09)
</success_criteria>

<output>
After completion, create `.planning/phases/10-fmcsa-compliance-reports/10-03-SUMMARY.md`
</output>
