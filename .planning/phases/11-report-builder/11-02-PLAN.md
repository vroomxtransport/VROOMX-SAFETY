---
phase: 11-report-builder
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/routes/reports.js
autonomous: true

must_haves:
  truths:
    - "All 9 report endpoints accept optional ?fields= query parameter to filter output columns"
    - "When fields param omitted, all fields returned (backward compatible)"
    - "Preview endpoints exist returning first 10 rows with totalCount for each report type"
    - "Preview response includes columns array with key/label/type for frontend rendering"
  artifacts:
    - path: "backend/routes/reports.js"
      provides: "Extended report endpoints with fields param and preview routes"
      contains: "/preview"
  key_links:
    - from: "backend/routes/reports.js"
      to: "backend/config/reportFieldDefinitions.js"
      via: "field validation and filtering"
      pattern: "require.*reportFieldDefinitions"
---

<objective>
Extend all 9 report endpoints to accept a `fields` query parameter for column filtering, and add `/preview` endpoints that return first 10 rows with metadata.

Purpose: Enable backend field filtering for reduced data transfer and dynamic PDF generation, plus preview functionality before full download.
Output: All report endpoints support ?fields=field1,field2, plus /dqf/preview, /vehicle-maintenance/preview, etc. endpoints
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-report-builder/11-RESEARCH.md
@backend/routes/reports.js
@backend/config/reportFieldDefinitions.js (created in 11-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fields parameter support to all report endpoints</name>
  <files>backend/routes/reports.js</files>
  <action>
Extend all 9 report endpoints in backend/routes/reports.js to accept an optional `fields` query parameter.

At the top of the file, add import:
```javascript
const { REPORT_FIELD_DEFINITIONS, getDefaultFields, validateFields } = require('../config/reportFieldDefinitions');
```

For each report endpoint (dqf, vehicle-maintenance, violations, audit, document-expiration, drug-alcohol-summary, dataq-history, accident-summary, maintenance-costs), add field filtering logic:

1. Parse fields parameter (comma-separated or use all fields if omitted):
```javascript
const { fields } = req.query;
// For backward compatibility: if no fields param, return ALL data (current behavior)
// Only filter if fields explicitly provided
let selectedFields = null;
if (fields) {
  selectedFields = fields.split(',').map(f => f.trim()).filter(Boolean);
  const validation = validateFields('reportType', selectedFields);
  if (!validation.valid) {
    throw new AppError(validation.error, 400);
  }
}
```

2. After building the full row data objects, filter to selected fields only if selectedFields is set:
```javascript
// If fields specified, filter row data to only those fields
const outputRows = selectedFields
  ? rows.map(row => {
      const filtered = {};
      selectedFields.forEach(key => {
        if (row.hasOwnProperty(key)) filtered[key] = row[key];
      });
      return filtered;
    })
  : rows; // Return all fields if none specified
```

3. For CSV/Excel exports, build dynamic headers from selected fields:
```javascript
if (format === 'csv' || format === 'xlsx') {
  const fieldDefs = REPORT_FIELD_DEFINITIONS['reportType'].fields;
  const exportFields = selectedFields || fieldDefs.map(f => f.key);

  const headers = {};
  const columns = [];
  exportFields.forEach(key => {
    const def = fieldDefs.find(f => f.key === key);
    if (def) {
      headers[key] = def.label;
      columns.push({ header: def.label, key, width: 15 });
    }
  });
  // Use headers/columns with exportService
}
```

Apply this pattern to all 9 endpoints. The report type string should match the REPORT_FIELD_DEFINITIONS keys:
- /dqf -> 'dqf'
- /vehicle-maintenance -> 'vehicle'
- /violations -> 'violations'
- /audit -> 'audit'
- /document-expiration -> 'document-expiration'
- /drug-alcohol-summary -> 'drug-alcohol'
- /dataq-history -> 'dataq-history'
- /accident-summary -> 'accident-summary'
- /maintenance-costs -> 'maintenance-costs'

IMPORTANT: Ensure backward compatibility - if `fields` param is not provided, return ALL fields as current behavior.
  </action>
  <verify>
    - `grep "REPORT_FIELD_DEFINITIONS" backend/routes/reports.js` shows import
    - `grep "validateFields" backend/routes/reports.js` shows usage in endpoints
    - Start backend, test: `curl "http://localhost:5001/api/reports/dqf?fields=driverName,cdlNumber"` returns only those fields
    - Test backward compat: `curl "http://localhost:5001/api/reports/dqf"` returns all fields (no regression)
  </verify>
  <done>All 9 report endpoints accept ?fields= parameter and filter output accordingly, backward compatible when omitted</done>
</task>

<task type="auto">
  <name>Task 2: Add preview endpoints for all report types</name>
  <files>backend/routes/reports.js</files>
  <action>
Add preview endpoints for each report type. Preview returns first 10 rows plus metadata.

IMPORTANT: Add preview routes BEFORE the main routes (e.g., /dqf/preview before /dqf) to avoid Express matching /preview as an :id parameter.

For each report type, add a preview endpoint following this pattern:

```javascript
// Preview endpoint - MUST be before /:id routes
const PREVIEW_LIMIT = 10;

router.get('/dqf/preview', checkPermission('reports', 'view'), asyncHandler(async (req, res) => {
  const { driverIds, fields } = req.query;
  const companyId = req.companyFilter.companyId;

  // Parse selected fields (default to all fields)
  const reportType = 'dqf';
  const fieldDefs = REPORT_FIELD_DEFINITIONS[reportType].fields;
  let selectedFields = fields
    ? fields.split(',').map(f => f.trim()).filter(Boolean)
    : fieldDefs.map(f => f.key);

  // Validate fields
  if (fields) {
    const validation = validateFields(reportType, selectedFields);
    if (!validation.valid) {
      throw new AppError(validation.error, 400);
    }
  }

  // Build query with filters
  const query = { companyId, status: 'active' };
  if (driverIds) {
    const ids = driverIds.split(',').filter(Boolean);
    if (ids.length > 0) query._id = { $in: ids.map(id => new mongoose.Types.ObjectId(id)) };
  }

  // Get total count
  const totalCount = await Driver.countDocuments(query);

  // Fetch limited data for preview (same sort as main report)
  const drivers = await Driver.find(query)
    .select('-ssn')
    .sort({ lastName: 1, firstName: 1 })
    .limit(PREVIEW_LIMIT)
    .lean();

  // Transform to row objects (same mapping as main endpoint)
  const allRows = drivers.map(d => ({
    driverName: `${d.firstName} ${d.lastName}`,
    employeeId: d.employeeId || '-',
    // ... same field mappings as main endpoint
  }));

  // Filter to selected fields
  const rows = allRows.map(row => {
    const filtered = {};
    selectedFields.forEach(key => {
      filtered[key] = row[key];
    });
    return filtered;
  });

  // Build columns array for frontend table headers
  const columns = selectedFields.map(key => {
    const def = fieldDefs.find(f => f.key === key);
    return {
      key,
      label: def?.label || key,
      type: def?.type || 'string'
    };
  });

  return res.json({
    success: true,
    preview: {
      rows,
      columns,
      totalCount,
      previewCount: rows.length,
      hasMore: totalCount > PREVIEW_LIMIT
    }
  });
}));
```

Create preview endpoints for all 9 report types:
- GET /dqf/preview
- GET /vehicle-maintenance/preview
- GET /violations/preview
- GET /audit/preview
- GET /document-expiration/preview
- GET /drug-alcohol-summary/preview
- GET /dataq-history/preview
- GET /accident-summary/preview
- GET /maintenance-costs/preview

Each preview endpoint should:
1. Accept same filter params as main endpoint + fields param
2. Use PREVIEW_LIMIT = 10
3. Use same data transformation as main endpoint (DRY: consider extracting shared row mapping)
4. Use same sort order as main endpoint
5. Return { success, preview: { rows, columns, totalCount, previewCount, hasMore } }

Consider creating helper functions to avoid duplicating row mapping logic between main and preview endpoints.
  </action>
  <verify>
    - `grep "/preview" backend/routes/reports.js | wc -l` shows 9+ matches (one per report type)
    - Start backend, test: `curl "http://localhost:5001/api/reports/dqf/preview"` returns JSON with preview.rows array
    - Verify preview has columns metadata: response contains preview.columns array
    - Verify limit works: preview.rows.length <= 10
  </verify>
  <done>All 9 report types have /preview endpoint returning first 10 rows with columns metadata and totalCount</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Backend starts without errors
2. Fields param works: `curl "http://localhost:5001/api/reports/dqf?fields=driverName,cdlNumber&format=json"` returns only those fields
3. Preview endpoints work: `curl "http://localhost:5001/api/reports/dqf/preview"` returns preview object with rows, columns, totalCount
4. Backward compatible: existing report generation without fields param still works
</verification>

<success_criteria>
- All 9 report endpoints accept ?fields= query param
- Field filtering applies to JSON, CSV, and Excel outputs
- Preview endpoints exist for all 9 report types
- Preview returns rows (max 10), columns (with label/type), totalCount, hasMore
- Backward compatibility maintained (no fields = all fields)
</success_criteria>

<output>
After completion, create `.planning/phases/11-report-builder/11-02-SUMMARY.md`
</output>
