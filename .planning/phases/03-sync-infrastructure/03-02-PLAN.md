---
phase: 03-sync-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/services/fmcsaSyncOrchestrator.js
autonomous: true

must_haves:
  truths:
    - "Orchestrator syncs CSA scores for a company"
    - "Orchestrator syncs violations from DataHub for a company"
    - "Orchestrator syncs inspection stats from SaferWebAPI for a company"
    - "Orchestrator updates Company.fmcsaData.syncStatus after each sync"
    - "Orchestrator logs errors but does not crash on any service failure"
    - "Orchestrator can sync all companies with DOT numbers"
  artifacts:
    - path: "backend/services/fmcsaSyncOrchestrator.js"
      provides: "syncAllCompanies and syncCompany functions"
      exports: ["syncAllCompanies", "syncCompany"]
  key_links:
    - from: "backend/services/fmcsaSyncOrchestrator.js"
      to: "backend/services/fmcsaSyncService.js"
      via: "syncCompanyData call"
      pattern: "fmcsaSyncService\\.syncCompanyData"
    - from: "backend/services/fmcsaSyncOrchestrator.js"
      to: "backend/services/fmcsaInspectionService.js"
      via: "syncViolationsFromDataHub call"
      pattern: "fmcsaInspectionService\\.syncViolationsFromDataHub"
    - from: "backend/services/fmcsaSyncOrchestrator.js"
      to: "backend/services/fmcsaViolationService.js"
      via: "syncViolationHistory call"
      pattern: "fmcsaViolationService\\.syncViolationHistory"
    - from: "backend/services/fmcsaSyncOrchestrator.js"
      to: "backend/models/Company.js"
      via: "syncStatus update"
      pattern: "fmcsaData\\.syncStatus"
---

<objective>
Create sync orchestrator service that coordinates all three FMCSA data sources

Purpose: Single entry point for FMCSA sync that coordinates CSA scores, violations, and inspections
Output: fmcsaSyncOrchestrator.js with syncAllCompanies() for cron and syncCompany() for single company
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sync-infrastructure/03-RESEARCH.md
@.planning/phases/03-sync-infrastructure/03-01-SUMMARY.md

# Existing services to coordinate
@backend/services/fmcsaSyncService.js
@backend/services/fmcsaViolationService.js
@backend/services/fmcsaInspectionService.js

# Company model with syncStatus schema
@backend/models/Company.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fmcsaSyncOrchestrator service</name>
  <files>backend/services/fmcsaSyncOrchestrator.js</files>
  <action>
Create a new orchestrator service that coordinates the three existing FMCSA services.

```javascript
/**
 * FMCSA Sync Orchestrator
 *
 * Coordinates sync across all FMCSA data sources:
 * 1. CSA BASIC scores (fmcsaSyncService -> SAFER)
 * 2. Violation details (fmcsaInspectionService -> DataHub)
 * 3. Inspection stats (fmcsaViolationService -> SaferWebAPI)
 *
 * Designed for cron job usage - never throws, always logs errors.
 */

const Company = require('../models/Company');
const fmcsaSyncService = require('./fmcsaSyncService');
const fmcsaInspectionService = require('./fmcsaInspectionService');
const fmcsaViolationService = require('./fmcsaViolationService');

const fmcsaSyncOrchestrator = {
  /**
   * Sync all companies with DOT numbers
   * Processes sequentially to avoid API rate limits
   *
   * @returns {object} Summary of sync results
   */
  async syncAllCompanies() {
    console.log('[FMCSA Orchestrator] Starting sync for all companies...');

    const companies = await Company.find({
      dotNumber: { $exists: true, $ne: null, $ne: '' }
    }).select('_id name dotNumber');

    console.log(`[FMCSA Orchestrator] Found ${companies.length} companies with DOT numbers`);

    const results = {
      total: companies.length,
      succeeded: 0,
      failed: 0,
      errors: []
    };

    // Process sequentially to avoid rate limiting
    for (const company of companies) {
      try {
        const result = await this.syncCompany(company._id);
        if (result.success) {
          results.succeeded++;
        } else {
          results.failed++;
          results.errors.push({ companyId: company._id, name: company.name, errors: result.errors });
        }
      } catch (error) {
        // Should never happen (syncCompany catches all), but safety first
        console.error(`[FMCSA Orchestrator] Unexpected error for ${company.name}:`, error.message);
        results.failed++;
        results.errors.push({ companyId: company._id, name: company.name, errors: [{ source: 'orchestrator', error: error.message }] });
      }
    }

    console.log(`[FMCSA Orchestrator] Sync complete: ${results.succeeded}/${results.total} succeeded`);
    return results;
  },

  /**
   * Sync all FMCSA data for a single company
   * Updates Company.fmcsaData.syncStatus with results
   *
   * @param {ObjectId|string} companyId - Company ID
   * @returns {object} Sync results with success flag and any errors
   */
  async syncCompany(companyId) {
    const errors = [];
    const timestamps = {};

    // 1. CSA BASIC scores from SAFER (via fmcsaSyncService)
    try {
      console.log(`[FMCSA Orchestrator] Syncing CSA scores for company ${companyId}`);
      const csaResult = await fmcsaSyncService.syncCompanyData(companyId);
      if (csaResult) {
        timestamps.csaScoresLastSync = new Date();
        console.log(`[FMCSA Orchestrator] CSA scores synced successfully`);
      } else {
        errors.push({ source: 'csa_scores', error: 'No data returned', timestamp: new Date() });
      }
    } catch (err) {
      console.error(`[FMCSA Orchestrator] CSA scores failed:`, err.message);
      errors.push({ source: 'csa_scores', error: err.message, timestamp: new Date() });
    }

    // 2. Violation details from DataHub (via fmcsaInspectionService)
    try {
      console.log(`[FMCSA Orchestrator] Syncing violations from DataHub for company ${companyId}`);
      const violationResult = await fmcsaInspectionService.syncViolationsFromDataHub(companyId);
      if (violationResult.success) {
        timestamps.violationsLastSync = new Date();
        console.log(`[FMCSA Orchestrator] Violations synced: ${violationResult.matched || 0} matched, ${violationResult.total || 0} total`);
      } else {
        errors.push({ source: 'violations', error: violationResult.message || 'Sync failed', timestamp: new Date() });
      }
    } catch (err) {
      console.error(`[FMCSA Orchestrator] Violations sync failed:`, err.message);
      errors.push({ source: 'violations', error: err.message, timestamp: new Date() });
    }

    // 3. Inspection stats from SaferWebAPI (via fmcsaViolationService)
    try {
      console.log(`[FMCSA Orchestrator] Syncing inspection stats from SaferWebAPI for company ${companyId}`);
      const inspectionResult = await fmcsaViolationService.syncViolationHistory(companyId);
      if (inspectionResult.success) {
        timestamps.inspectionsLastSync = new Date();
        console.log(`[FMCSA Orchestrator] Inspection stats synced: ${inspectionResult.imported || 0} inspections`);
      } else {
        errors.push({ source: 'inspections', error: inspectionResult.message || 'Sync failed', timestamp: new Date() });
      }
    } catch (err) {
      console.error(`[FMCSA Orchestrator] Inspection stats failed:`, err.message);
      errors.push({ source: 'inspections', error: err.message, timestamp: new Date() });
    }

    // Update Company sync status
    const success = errors.length === 0;
    await Company.updateOne(
      { _id: companyId },
      {
        $set: {
          'fmcsaData.syncStatus.lastRun': new Date(),
          'fmcsaData.syncStatus.success': success,
          'fmcsaData.syncStatus.errors': errors,
          ...(timestamps.csaScoresLastSync && { 'fmcsaData.syncStatus.csaScoresLastSync': timestamps.csaScoresLastSync }),
          ...(timestamps.violationsLastSync && { 'fmcsaData.syncStatus.violationsLastSync': timestamps.violationsLastSync }),
          ...(timestamps.inspectionsLastSync && { 'fmcsaData.syncStatus.inspectionsLastSync': timestamps.inspectionsLastSync })
        }
      }
    );

    return { success, errors };
  }
};

module.exports = fmcsaSyncOrchestrator;
```

Key design decisions:
- Sequential company processing (not parallel) to avoid API rate limits
- Each source sync wrapped in try/catch - one failure doesn't stop others
- Per-source timestamps allow tracking partial success
- All errors logged to console AND stored in Company.fmcsaData.syncStatus.errors
- Never throws from public methods - safe for cron usage
  </action>
  <verify>
Run: `node -e "const o = require('./backend/services/fmcsaSyncOrchestrator'); console.log('syncAllCompanies:', typeof o.syncAllCompanies); console.log('syncCompany:', typeof o.syncCompany);"`

Should output:
```
syncAllCompanies: function
syncCompany: function
```
  </verify>
  <done>Orchestrator service exports syncAllCompanies() and syncCompany() functions</done>
</task>

<task type="auto">
  <name>Task 2: Verify orchestrator can load all dependencies</name>
  <files>backend/services/fmcsaSyncOrchestrator.js</files>
  <action>
Verify the orchestrator loads without errors by requiring all its dependencies:

```bash
cd backend && node -e "
const o = require('./services/fmcsaSyncOrchestrator');
const Company = require('./models/Company');
const fmcsaSyncService = require('./services/fmcsaSyncService');
const fmcsaInspectionService = require('./services/fmcsaInspectionService');
const fmcsaViolationService = require('./services/fmcsaViolationService');
console.log('All dependencies loaded successfully');
console.log('Orchestrator methods:', Object.keys(o).join(', '));
"
```

If any require fails, fix the import path.
  </action>
  <verify>Command above outputs "All dependencies loaded successfully" and lists both methods</verify>
  <done>Orchestrator loads without errors and has access to all three FMCSA services</done>
</task>

</tasks>

<verification>
1. Service file exists: `ls -la backend/services/fmcsaSyncOrchestrator.js`
2. Service loads: `node -e "require('./backend/services/fmcsaSyncOrchestrator')"`
3. Has correct exports: `node -e "const o = require('./backend/services/fmcsaSyncOrchestrator'); console.log(Object.keys(o));"`
4. Backend starts: `cd backend && npm run dev` (no require errors)
</verification>

<success_criteria>
- fmcsaSyncOrchestrator.js exists in backend/services/
- Service exports syncAllCompanies() and syncCompany() functions
- Service requires all three FMCSA services without errors
- Service follows codebase error handling pattern (log, don't throw)
</success_criteria>

<output>
After completion, create `.planning/phases/03-sync-infrastructure/03-02-SUMMARY.md`
</output>
