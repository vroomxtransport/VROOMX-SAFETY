---
phase: 02-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/scripts/migrate-violations.js
autonomous: true

must_haves:
  truths:
    - "All embedded violations from FMCSAInspection.violations[] exist as Violation documents"
    - "Each Violation document has inspectionNumber linking it to source inspection"
    - "FMCSAInspection.violationRefs[] populated with ObjectIds of migrated Violations"
    - "No duplicate Violation records exist after migration"
    - "Migration can run multiple times with same result (idempotent)"
  artifacts:
    - path: "backend/scripts/migrate-violations.js"
      provides: "Migration script with batch processing, checkpoints, field transformation"
      min_lines: 150
      exports: ["runMigration", "verifyMigration"]
  key_links:
    - from: "backend/scripts/migrate-violations.js"
      to: "backend/models/FMCSAInspection.js"
      via: "find().cursor() iteration"
      pattern: "FMCSAInspection\\.find"
    - from: "backend/scripts/migrate-violations.js"
      to: "backend/models/Violation.js"
      via: "insertMany for batch insert"
      pattern: "Violation\\.insertMany"
    - from: "backend/scripts/migrate-violations.js"
      to: "_migrationState collection"
      via: "checkpoint save/restore"
      pattern: "collection\\(['\"]_migrationState['\"]\\)"
---

<objective>
Create idempotent migration script that extracts all embedded violations from FMCSAInspection.violations[] arrays into standalone Violation documents, with checkpoint-based resumability, batch processing, and post-migration verification.

Purpose: Establish Violation model as single source of truth (SSOT) by migrating existing embedded data
Output: Executable migration script with verification that can run safely multiple times
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-migration/02-CONTEXT.md
@.planning/phases/02-migration/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@backend/models/Violation.js
@backend/models/FMCSAInspection.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration script with batch processing and checkpoints</name>
  <files>backend/scripts/migrate-violations.js</files>
  <action>
Create a Node.js migration script with the following components:

**Field Mapping Function** (`transformEmbeddedToViolation`):
Transform embedded violation to Violation schema. Map these fields:
- `embedded.code` -> `violationCode`
- `embedded.description` -> `description` AND `violationType` (use same value)
- `embedded.basic` -> `basic` (default: 'vehicle_maintenance' if missing)
- `embedded.severityWeight` -> `severityWeight` (default: 5 if missing)
- `embedded.oos` -> `outOfService` (boolean coercion)
- `embedded.unit` -> ignored (not in Violation schema)
- `embedded.timeWeight` -> ignored (calculated dynamically)

Add from inspection context:
- `inspection.companyId` -> `companyId`
- `inspection.reportNumber` -> `inspectionNumber`
- `inspection.inspectionDate` -> `violationDate`
- `inspection.state` -> `location.state`
- `inspection.location` -> `location.address`
- `inspection.inspectionLevel` -> `inspectionLevel`
- `inspection.inspectionType` -> `inspectionType` (default: 'roadside')

Set migration metadata:
- `syncMetadata.source` = 'legacy_migration'
- `syncMetadata.importedAt` = new Date()
- `syncMetadata.externalId` = `${inspection.reportNumber}_${embedded.code || 'unknown'}`
- `status` = 'open'
- `linkingMetadata.reviewRequired` = false

**Checkpoint Functions**:
- `getLastCheckpoint(db)`: Read from `_migrationState` collection, return lastProcessedId
- `saveCheckpoint(db, lastProcessedId, stats)`: Upsert to `_migrationState` with migration name 'violations_to_ssot_v1'

**Batch Processing** (`processBatch`):
- Take array of FMCSAInspection documents
- For each inspection, transform all embedded violations
- Use `Violation.insertMany(docs, { ordered: false })` to skip duplicates via unique index
- Handle E11000 duplicate key errors gracefully - parse error.insertedDocs and error.writeErrors
- After successful inserts, update `FMCSAInspection.violationRefs` with new ObjectIds
- Return { inserted: N, duplicates: N, inspectionsProcessed: N }

**Main Migration Function** (`runMigration`):
- Connect to MongoDB using existing mongoose connection pattern
- Get last checkpoint, build query with `{ _id: { $gt: lastId } }` if resuming
- Add filter `{ 'violations.0': { $exists: true } }` to only process inspections with embedded violations
- Use cursor with `batchSize(500)` and `sort({ _id: 1 })`
- Process in batches, save checkpoint after each batch
- Log progress: `[Migration] Processed X inspections, Y violations inserted, Z duplicates skipped`
- On completion, save final checkpoint with `completed: true, completedAt: new Date()`

**Dry Run Mode**:
- Accept `--dry-run` CLI flag
- In dry run: log what would be inserted but don't write to database
- Still calculate counts and show summary

**CLI Interface**:
- `node scripts/migrate-violations.js` - run migration
- `node scripts/migrate-violations.js --dry-run` - preview only
- `node scripts/migrate-violations.js --verify` - run verification only
- `node scripts/migrate-violations.js --reset` - clear checkpoint (for re-running from scratch)

Require MONGODB_URI environment variable. Use dotenv for local development.
  </action>
  <verify>
- `node backend/scripts/migrate-violations.js --dry-run` executes without errors and shows preview counts
- Script file exists at backend/scripts/migrate-violations.js
- Script has transformEmbeddedToViolation function with correct field mapping
- Script has checkpoint save/restore using _migrationState collection
  </verify>
  <done>
Migration script created with batch processing, checkpoint tracking, duplicate handling via ordered:false, and CLI interface with dry-run mode
  </done>
</task>

<task type="auto">
  <name>Task 2: Add verification functions to migration script</name>
  <files>backend/scripts/migrate-violations.js</files>
  <action>
Add verification functions to the existing migration script:

**Pre-migration Count** (`countEmbeddedViolations`):
```javascript
async function countEmbeddedViolations() {
  const result = await FMCSAInspection.aggregate([
    { $match: { 'violations.0': { $exists: true } } },
    { $unwind: '$violations' },
    { $count: 'total' }
  ]);
  return result[0]?.total || 0;
}
```

**Post-migration Count** (`countMigratedViolations`):
```javascript
async function countMigratedViolations() {
  return Violation.countDocuments({ 'syncMetadata.source': 'legacy_migration' });
}
```

**Sample Verification** (`verifySample`):
- Use `FMCSAInspection.aggregate` with `$sample: { size: 10 }` to get random inspections with embedded violations
- For each sampled inspection:
  - Count embedded violations: `inspection.violations.length`
  - Count migrated violations: `Violation.countDocuments({ inspectionNumber: inspection.reportNumber, 'syncMetadata.source': 'legacy_migration' })`
  - Check `inspection.violationRefs.length` matches migrated count
  - If mismatch, add to issues array
- Return { sampled: N, passed: N, issues: [...] }

**violationRefs Verification** (`verifyViolationRefs`):
- Count inspections where `violations.0` exists but `violationRefs.0` does not
- These are unmigrated inspections (should be 0 after successful migration)

**Main Verify Function** (`verifyMigration`):
```javascript
async function verifyMigration() {
  console.log('[Verify] Starting migration verification...');

  const embeddedCount = await countEmbeddedViolations();
  console.log(`[Verify] Embedded violations: ${embeddedCount}`);

  const migratedCount = await countMigratedViolations();
  console.log(`[Verify] Migrated violations: ${migratedCount}`);

  const sampleResult = await verifySample(10);
  console.log(`[Verify] Sample check: ${sampleResult.passed}/${sampleResult.sampled} passed`);

  const unmigrated = await verifyViolationRefs();
  console.log(`[Verify] Inspections without violationRefs: ${unmigrated}`);

  const success = embeddedCount === migratedCount &&
                  sampleResult.issues.length === 0 &&
                  unmigrated === 0;

  console.log(`[Verify] Overall: ${success ? 'PASSED' : 'FAILED'}`);

  if (sampleResult.issues.length > 0) {
    console.log('[Verify] Issues found:');
    sampleResult.issues.forEach(issue => console.log(JSON.stringify(issue)));
  }

  return { success, embeddedCount, migratedCount, sampleResult, unmigrated };
}
```

Wire `--verify` CLI flag to call `verifyMigration()` and exit.

Export both `runMigration` and `verifyMigration` for programmatic use:
```javascript
module.exports = { runMigration, verifyMigration };
```

Add shebang and make script directly executable:
```javascript
#!/usr/bin/env node
```
  </action>
  <verify>
- `node backend/scripts/migrate-violations.js --verify` runs verification functions
- Script exports both runMigration and verifyMigration functions
- Verification includes embedded count, migrated count, sample check, and violationRefs check
  </verify>
  <done>
Migration script includes comprehensive verification: pre/post counts, random sample verification, violationRefs population check, and CLI --verify flag
  </done>
</task>

</tasks>

<verification>
1. Run dry-run to verify script executes without errors:
   `node backend/scripts/migrate-violations.js --dry-run`

2. Verify script structure with grep:
   - `grep -q "transformEmbeddedToViolation" backend/scripts/migrate-violations.js`
   - `grep -q "_migrationState" backend/scripts/migrate-violations.js`
   - `grep -q "ordered: false" backend/scripts/migrate-violations.js`
   - `grep -q "verifyMigration" backend/scripts/migrate-violations.js`

3. Check exports:
   `grep -q "module.exports" backend/scripts/migrate-violations.js`
</verification>

<success_criteria>
- Migration script exists at backend/scripts/migrate-violations.js
- Script handles batch processing with configurable batch size (default 500)
- Script uses checkpoint tracking via _migrationState collection for resumability
- Script handles duplicates via ordered:false and unique index (no pre-checking)
- Script updates FMCSAInspection.violationRefs after inserts
- Script includes verification functions for pre/post counts and sample checks
- Script supports CLI flags: --dry-run, --verify, --reset
- Dry-run mode works without database writes
- Migration is idempotent (running twice produces same result)
</success_criteria>

<output>
After completion, create `.planning/phases/02-migration/02-01-SUMMARY.md`
</output>
